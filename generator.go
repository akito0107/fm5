package fmgo

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/token"
	"io"
	"strconv"

	"github.com/k0kubun/pp"

	"github.com/iancoleman/strcase"
	"github.com/pkg/errors"
	"golang.org/x/tools/imports"
)

type Generator struct {
	pkgName  string
	typeName string
	f        *ast.File
	ts       *ast.TypeSpec
}

func NewGenerator(pkgName string, typeName string, ts *ast.TypeSpec) *Generator {
	return &Generator{
		pkgName:  pkgName,
		typeName: typeName,
		f:        &ast.File{},
		ts:       ts,
	}
}

func (g *Generator) Generate() error {
	g.AppendPackage()
	return nil
}

func (g *Generator) AppendPackage() {
	g.f.Name = &ast.Ident{
		Name: g.pkgName,
	}
}

func (g *Generator) AppendDefaultFactory(methodname string) error {
	d, err := appendDefaultFactory(g.ts, g.typeName, methodname)
	if err != nil {
		return err
	}
	g.f.Decls = append(g.f.Decls, d...)
	return nil
}

func (g *Generator) AppendErrorImplementation(message string) error {
	d, err := appendErrorImplementation(g.ts, message)
	if err != nil {
		return err
	}
	g.f.Decls = append(g.f.Decls, d...)
	return nil
}

func (g *Generator) Out(w io.Writer) error {
	var buf bytes.Buffer
	fmt.Fprintf(&buf, "// Code generated by \"generr\"; DO NOT EDIT.\n")
	format.Node(&buf, token.NewFileSet(), g.f)
	targ, err := imports.Process("", buf.Bytes(), &imports.Options{Comments: true})
	if err != nil {
		return err
	}
	if _, err := io.Copy(w, bytes.NewReader(targ)); err != nil {
		return err
	}
	return nil
}

//go:generate ./bin/generr -t notStructType -i
type notStructType interface {
	NotStructType() (typename string)
}

func appendDefaultFactory(ts *ast.TypeSpec, typeName, methodName string) ([]ast.Decl, error) {
	st, ok := ts.Type.(*ast.StructType)
	pp.Println(st)
	if !ok {
		return nil, &NotStructType{Typename: fmt.Sprintf("%v", ts.Type)}
	}
	ret := &ast.ReturnStmt{
		Results: []ast.Expr{
			&ast.UnaryExpr{
				Op: token.AND,
				X: &ast.CompositeLit{
					Type: ast.NewIdent(typeName),
				},
			},
		},
	}

	decls := []ast.Decl{
		&ast.FuncDecl{
			Name: ast.NewIdent(methodName),
			Type: &ast.FuncType{
				Params: &ast.FieldList{},
				Results: &ast.FieldList{
					List: []*ast.Field{
						{
							Type: &ast.StarExpr{
								X: ast.NewIdent(typeName),
							},
						},
					},
				},
			},
			Body: &ast.BlockStmt{
				List: []ast.Stmt{ret},
			},
		},
	}

	return decls, nil
}

func appendErrorImplementation(ts *ast.TypeSpec, mes string) ([]ast.Decl, error) {
	it, ok := ts.Type.(*ast.InterfaceType)
	if !ok {
		return nil, errors.Errorf("type %+v is not a interface", ts.Type)
	}
	ft, ok := it.Methods.List[0].Type.(*ast.FuncType)
	if !ok {
		return nil, errors.Errorf("type %+v has no function", it)
	}

	var decls []ast.Decl
	name := strcase.ToCamel(ts.Name.Name)

	var fields []*ast.Field
	var rtTypes []*ast.Field
	var rtExprs []ast.Expr
	errorReturnExpr := &ast.CallExpr{
		Fun: &ast.SelectorExpr{
			X:   ast.NewIdent("fmt"),
			Sel: ast.NewIdent("Sprint"),
		},
		Args: []ast.Expr{
			ast.NewIdent(strconv.Quote(ts.Name.Name)),
		},
	}

	if ft.Results != nil {
		message := ts.Name.Name
		for _, f := range ft.Results.List {
			camelName := strcase.ToCamel(f.Names[0].Name)
			fields = append(fields, &ast.Field{
				Names: []*ast.Ident{
					ast.NewIdent(camelName),
				},
				Type: f.Type,
			})

			rtTypes = append(rtTypes, &ast.Field{
				Type: f.Type,
			})

			rtExprs = append(rtExprs, &ast.SelectorExpr{
				X:   ast.NewIdent("e"),
				Sel: ast.NewIdent(camelName),
			})
			message = fmt.Sprintf("%s %s: %s", message, camelName, "%v")
		}
		if mes == "" {
			mes = message
		}
		args := []ast.Expr{ast.NewIdent(strconv.Quote(mes))}
		args = append(args, rtExprs...)
		errorReturnExpr = &ast.CallExpr{
			Fun: &ast.SelectorExpr{
				X:   ast.NewIdent("fmt"),
				Sel: ast.NewIdent("Sprintf"),
			},
			Args: args,
		}
	}

	decls = append(decls, &ast.GenDecl{
		Tok: token.TYPE,
		Specs: []ast.Spec{
			&ast.TypeSpec{
				Name: ast.NewIdent(name),
				Type: &ast.StructType{
					Fields: &ast.FieldList{
						List: fields,
					},
				},
			},
		},
	})

	decls = append(decls, &ast.FuncDecl{
		Recv: &ast.FieldList{
			List: []*ast.Field{
				{
					Names: []*ast.Ident{ast.NewIdent("e")},
					Type:  ast.NewIdent("*" + name),
				},
			},
		},
		Type: &ast.FuncType{
			Params: &ast.FieldList{},
			Results: &ast.FieldList{
				List: rtTypes,
			},
		},
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				&ast.ReturnStmt{
					Results: rtExprs,
				},
			},
		},
		Name: ast.NewIdent(name),
	})

	decls = append(decls, &ast.FuncDecl{
		Recv: &ast.FieldList{
			List: []*ast.Field{
				{
					Names: []*ast.Ident{ast.NewIdent("e")},
					Type:  ast.NewIdent("*" + name),
				},
			},
		},
		Type: &ast.FuncType{
			Params: &ast.FieldList{},
			Results: &ast.FieldList{
				List: []*ast.Field{
					{
						Type: ast.NewIdent("string"),
					},
				},
			},
		},
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				&ast.ReturnStmt{
					Results: []ast.Expr{
						errorReturnExpr,
					},
				},
			},
		},
		Name: ast.NewIdent("Error"),
	})

	return decls, nil
}
