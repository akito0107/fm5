package fm5

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/token"
	"io"
	"strings"

	"golang.org/x/tools/imports"
)

type Generator struct {
	pkgName  string
	typeName string
	f        *ast.File
	ts       *ast.TypeSpec
}

func NewGenerator(pkgName string, typeName string, ts *ast.TypeSpec) *Generator {
	return &Generator{
		pkgName:  pkgName,
		typeName: typeName,
		f:        &ast.File{},
		ts:       ts,
	}
}

func (g *Generator) Generate() error {
	g.AppendPackage()
	return nil
}

func (g *Generator) AppendPackage() {
	g.f.Name = &ast.Ident{
		Name: g.pkgName,
	}
}

func (g *Generator) AppendDefaultFactory(methodname string) error {
	d, err := appendDefaultFactory(g.ts, g.typeName, methodname)
	if err != nil {
		return err
	}
	g.f.Decls = append(g.f.Decls, d...)
	return nil
}

func (g *Generator) AppendFunctionalOptionType(methodname string) error {
	d, err := appendFunctionalOptionType(g.typeName, methodname)
	if err != nil {
		return err
	}
	g.f.Decls = append(g.f.Decls, d...)
	return nil
}

func (g *Generator) AppendFunctionalOptions() error {
	d, err := appendFunctionalOptions(g.ts, g.typeName)
	if err != nil {
		return err
	}
	g.f.Decls = append(g.f.Decls, d...)
	return nil
}

func (g *Generator) Out(w io.Writer) error {
	var buf bytes.Buffer
	fmt.Fprintf(&buf, "// Code generated by \"fmgo\"; DO NOT EDIT.\n")
	format.Node(&buf, token.NewFileSet(), g.f)
	targ, err := imports.Process("", buf.Bytes(), &imports.Options{Comments: true})
	if err != nil {
		return err
	}
	if _, err := io.Copy(w, bytes.NewReader(targ)); err != nil {
		return err
	}
	return nil
}

//go:generate ./bin/generr -t notStructType -i
type notStructType interface {
	NotStructType() (typename string)
}

func appendDefaultFactory(ts *ast.TypeSpec, typeName, methodName string) ([]ast.Decl, error) {
	st, ok := ts.Type.(*ast.StructType)
	if !ok {
		return nil, &NotStructType{Typename: fmt.Sprintf("%v", ts.Type)}
	}
	var elts []ast.Expr

	for _, f := range st.Fields.List {
		name := f.Names[0]
		elts = append(elts, &ast.KeyValueExpr{Key: name, Value: name})
	}
	ret := &ast.ReturnStmt{
		Results: []ast.Expr{
			&ast.UnaryExpr{
				Op: token.AND,
				X: &ast.CompositeLit{
					Type: ast.NewIdent(typeName),
					Elts: elts,
				},
			},
		},
	}

	decls := []ast.Decl{
		&ast.FuncDecl{
			Name: ast.NewIdent(methodName),
			Type: &ast.FuncType{
				Params: st.Fields,
				Results: &ast.FieldList{
					List: []*ast.Field{
						{
							Type: &ast.StarExpr{
								X: ast.NewIdent(typeName),
							},
						},
					},
				},
			},
			Body: &ast.BlockStmt{
				List: []ast.Stmt{ret},
			},
		},
	}

	return decls, nil
}

func appendFunctionalOptionType(typename, methodname string) ([]ast.Decl, error) {
	optDef := &ast.GenDecl{
		Tok: token.TYPE,
		Specs: []ast.Spec{
			&ast.TypeSpec{
				Name:   ast.NewIdent(typename + "Option"),
				Assign: token.NoPos,
				Type: &ast.FuncType{
					Params: &ast.FieldList{
						List: []*ast.Field{
							{
								Type: &ast.StarExpr{
									X: ast.NewIdent(typename),
								},
							},
						},
					},
					Results: &ast.FieldList{},
				},
			},
		},
	}

	params := &ast.FieldList{
		List: []*ast.Field{
			{
				Names: []*ast.Ident{ast.NewIdent("opts")},
				Type: &ast.Ellipsis{
					Elt: ast.NewIdent(typename + "Option"),
				},
			},
		},
	}
	fBody := &ast.BlockStmt{
		List: []ast.Stmt{
			&ast.AssignStmt{
				Lhs: []ast.Expr{
					ast.NewIdent("i"),
				},
				Tok: token.DEFINE,
				Rhs: []ast.Expr{
					&ast.UnaryExpr{
						Op: token.AND,
						X: &ast.CompositeLit{
							Type: ast.NewIdent(typename),
						},
					},
				},
			},
			&ast.RangeStmt{
				X:     ast.NewIdent("opts"),
				Key:   ast.NewIdent("_"),
				Value: ast.NewIdent("o"),
				Tok:   token.DEFINE,
				Body: &ast.BlockStmt{
					List: []ast.Stmt{
						&ast.ExprStmt{
							X: &ast.CallExpr{
								Fun: ast.NewIdent("o"),
								Args: []ast.Expr{
									ast.NewIdent("i"),
								},
							},
						},
					},
				},
			},
			&ast.ReturnStmt{
				Results: []ast.Expr{
					ast.NewIdent("i"),
				},
			},
		},
	}

	fDecl := &ast.FuncDecl{
		Name: ast.NewIdent(methodname),
		Type: &ast.FuncType{Params: params, Results: &ast.FieldList{
			List: []*ast.Field{
				{
					Type: &ast.StarExpr{
						X: ast.NewIdent(typename),
					},
				},
			},
		}},
		Body: fBody,
	}

	res := []ast.Decl{
		optDef,
		fDecl,
	}

	return res, nil
}

func appendFunctionalOptions(ts *ast.TypeSpec, typename string) ([]ast.Decl, error) {
	st, ok := ts.Type.(*ast.StructType)
	if !ok {
		return nil, &NotStructType{Typename: fmt.Sprintf("%v", ts.Type)}
	}

	var res []ast.Decl
	for _, f := range st.Fields.List {
		name := f.Names[0].Name
		fdecl := &ast.FuncDecl{
			Name: ast.NewIdent("With" + strings.Title(name)),
			Type: &ast.FuncType{
				Params: &ast.FieldList{
					List: []*ast.Field{
						f,
					},
				},
				Results: &ast.FieldList{
					List: []*ast.Field{
						{
							Type: ast.NewIdent(typename + "Option"),
						},
					},
				},
			},
			Body: &ast.BlockStmt{
				List: []ast.Stmt{
					&ast.ReturnStmt{
						Results: []ast.Expr{
							&ast.FuncLit{
								Type: &ast.FuncType{
									Params: &ast.FieldList{
										List: []*ast.Field{
											{
												Names: []*ast.Ident{
													ast.NewIdent("i"),
												},
												Type: &ast.StarExpr{
													X: ast.NewIdent(typename),
												},
											},
										},
									},
									Results: nil,
								},
								Body: &ast.BlockStmt{
									List: []ast.Stmt{
										&ast.AssignStmt{
											Lhs: []ast.Expr{
												&ast.SelectorExpr{
													X:   ast.NewIdent("i"),
													Sel: ast.NewIdent(name),
												},
											},
											Tok: token.ASSIGN,
											Rhs: []ast.Expr{ast.NewIdent(name)},
										},
									},
								},
							},
						},
					},
				},
			},
		}
		res = append(res, fdecl)
	}

	return res, nil
}
