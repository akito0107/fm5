package fm5

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/token"
	"io"

	"golang.org/x/tools/imports"
)

type Generator struct {
	pkgName  string
	typeName string
	f        *ast.File
	ts       *ast.TypeSpec
}

func NewGenerator(pkgName string, typeName string, ts *ast.TypeSpec) *Generator {
	return &Generator{
		pkgName:  pkgName,
		typeName: typeName,
		f:        &ast.File{},
		ts:       ts,
	}
}

func (g *Generator) Generate() error {
	g.AppendPackage()
	return nil
}

func (g *Generator) AppendPackage() {
	g.f.Name = &ast.Ident{
		Name: g.pkgName,
	}
}

func (g *Generator) AppendDefaultFactory(methodname string) error {
	d, err := appendDefaultFactory(g.ts, g.typeName, methodname)
	if err != nil {
		return err
	}
	g.f.Decls = append(g.f.Decls, d...)
	return nil
}

func (g *Generator) AppendFunctionalOptionType(methodname string) error {
	d, err := appendFunctionalOptionType(g.typeName, methodname)
	if err != nil {
		return err
	}
	g.f.Decls = append(g.f.Decls, d...)
	return nil
}

func (g *Generator) Out(w io.Writer) error {
	var buf bytes.Buffer
	fmt.Fprintf(&buf, "// Code generated by \"fmgo\"; DO NOT EDIT.\n")
	format.Node(&buf, token.NewFileSet(), g.f)
	targ, err := imports.Process("", buf.Bytes(), &imports.Options{Comments: true})
	if err != nil {
		return err
	}
	if _, err := io.Copy(w, bytes.NewReader(targ)); err != nil {
		return err
	}
	return nil
}

//go:generate ./bin/generr -t notStructType -i
type notStructType interface {
	NotStructType() (typename string)
}

func appendDefaultFactory(ts *ast.TypeSpec, typeName, methodName string) ([]ast.Decl, error) {
	st, ok := ts.Type.(*ast.StructType)
	if !ok {
		return nil, &NotStructType{Typename: fmt.Sprintf("%v", ts.Type)}
	}
	var elts []ast.Expr

	for _, f := range st.Fields.List {
		name := f.Names[0]
		elts = append(elts, &ast.KeyValueExpr{Key: name, Value: name})
	}
	ret := &ast.ReturnStmt{
		Results: []ast.Expr{
			&ast.UnaryExpr{
				Op: token.AND,
				X: &ast.CompositeLit{
					Type: ast.NewIdent(typeName),
					Elts: elts,
				},
			},
		},
	}

	decls := []ast.Decl{
		&ast.FuncDecl{
			Name: ast.NewIdent(methodName),
			Type: &ast.FuncType{
				Params: st.Fields,
				Results: &ast.FieldList{
					List: []*ast.Field{
						{
							Type: &ast.StarExpr{
								X: ast.NewIdent(typeName),
							},
						},
					},
				},
			},
			Body: &ast.BlockStmt{
				List: []ast.Stmt{ret},
			},
		},
	}

	return decls, nil
}

func appendFunctionalOptionType(typename, methodname string) ([]ast.Decl, error) {
	optDef := &ast.GenDecl{
		Tok: token.TYPE,
		Specs: []ast.Spec{
			&ast.TypeSpec{
				Name:   ast.NewIdent(typename + "Option"),
				Assign: token.NoPos,
				Type: &ast.FuncType{
					Params: &ast.FieldList{
						List: []*ast.Field{
							{
								Type: &ast.StarExpr{
									X: ast.NewIdent(typename),
								},
							},
						},
					},
					Results: &ast.FieldList{},
				},
			},
		},
	}

	ret := &ast.ReturnStmt{
		Results: []ast.Expr{
			&ast.UnaryExpr{
				Op: token.AND,
				X: &ast.CompositeLit{
					Type: ast.NewIdent(typename),
				},
			},
		},
	}

	params := &ast.FieldList{
		List: []*ast.Field{
			{
				Names: []*ast.Ident{ast.NewIdent("opts")},
				Type: &ast.Ellipsis{
					Elt: ast.NewIdent(typename + "Option"),
				},
			},
		},
	}

	fDecl := &ast.FuncDecl{
		Name: ast.NewIdent(methodname),
		Type: &ast.FuncType{Params: params},
		Body: &ast.BlockStmt{
			List: []ast.Stmt{ret},
		},
	}

	res := []ast.Decl{
		optDef,
		fDecl,
	}

	return res, nil
}
