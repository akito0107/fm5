package e2e

import (
	"bytes"
	"os/exec"
	"reflect"
	"testing"
)

func TestE2E(t *testing.T) {
	cases := []struct {
		name    string
		options []string
		expect  string
	}{
		{
			name:    "simple",
			options: []string{"-t", "SimpleStruct", "--dryrun"},
			expect: `// Code generated by "fmgo"; DO NOT EDIT.
package e2e

func NewSimpleStruct(id string, name string) *SimpleStruct {
	return &SimpleStruct{id: id, name: name}
}
`,
		},
		{
			name:    "method name option",
			options: []string{"-t", "SimpleStruct", "--dryrun", "-fmn", "NewStr"},
			expect: `// Code generated by "fmgo"; DO NOT EDIT.
package e2e

func NewStr(id string, name string) *SimpleStruct {
	return &SimpleStruct{id: id, name: name}
}
`,
		},
		{
			name:    "with functional option",
			options: []string{"-t", "SimpleStruct", "--dryrun", "-fo"},
			expect: `// Code generated by "fmgo"; DO NOT EDIT.
package e2e

func NewSimpleStruct(id string, name string) *SimpleStruct {
	return &SimpleStruct{id: id, name: name}
}

type SimpleStructOption func(*SimpleStruct)

func NewSimpleStructOptions(opts ...SimpleStructOption) *SimpleStruct {
	i := &SimpleStruct{}
	for _, o := range opts {
		o(i)
	}
	return i
}
func WithId(id string) SimpleStructOption {
	return func(i *SimpleStruct) {
		i.id = id
	}
}
func WithName(name string) SimpleStructOption {
	return func(i *SimpleStruct) {
		i.name = name
	}
}
`,
		},
		{
			name:    "with functional option and given typename",
			options: []string{"-t", "SimpleStruct", "--dryrun", "-fo", "-r", "Interface"},
			expect: `// Code generated by "fmgo"; DO NOT EDIT.
package e2e

func NewSimpleStruct(id string, name string) Interface {
	return &SimpleStruct{id: id, name: name}
}

type SimpleStructOption func(*SimpleStruct)

func NewSimpleStructOptions(opts ...SimpleStructOption) Interface {
	i := &SimpleStruct{}
	for _, o := range opts {
		o(i)
	}
	return i
}
func WithId(id string) SimpleStructOption {
	return func(i *SimpleStruct) {
		i.id = id
	}
}
func WithName(name string) SimpleStructOption {
	return func(i *SimpleStruct) {
		i.name = name
	}
}
`,
		},
	}

	for _, c := range cases {
		t.Run(c.name, func(t *testing.T) {
			cmd := exec.Command("./fm5", c.options...)
			var out bytes.Buffer
			cmd.Stdout = &out
			err := cmd.Run()
			if err != nil {
				t.Fatalf("%+v", err)
			}
			if !reflect.DeepEqual(out.String(), out.String()) {
				t.Errorf("must be same %+v but actual %+v", c.expect, out.String())
			}
		})
	}
}
